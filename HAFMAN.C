#include <stdio.h>

FILE * fp1, * fp2, * fp3;  // Файловые переменные.


// Таблица символов и частот их появления.
float f[256],fz[256];      // Массивы для хранения частот символов
int symb[256];             // Массив для хранения кодов символов.
int nom_v_der[256];        // Массив для хранения номеров соответствующего элемента в дереве.
int k_tab_f;               // Количество элементов в таблице символов

// Дерево.
int lev_ssylka[512];       // Левая ссылка элемента дерева.
int prav_ssylka[512];      // Правая ссылка элемента дерева.
char vid_elem[512];        // Вид элемента дерева ('L'-Лист 'S'-Ссылочный лемент)
int symb_elem[512];        // Символ хранящийся в элементе дерева или сумма нескольких элементов.
float f_elem[512];         // Частота в тексте символа хранящегося в текущем элементе дерева или суммы символов.
int k_el_derevo;           // Количество элементов в дереве Хаффмана.
int k_list_el;             // Количество листовых элементов в дереве Хаффмана.
int k_ssyl_el;             // Количество ссылочных элементов в дереве Хаффмана.
int nom_koren;             // Номер корневого элемента дерева.

int nom_poz_kod_symb[256]; // Номер позиции в массиве spis_kod[] с которого начинается архивный код символа. (Для каждого символа).
int dl_kod_symb[256];      // Длина архивного кода символа в массиве spis_kod[]. (Для каждого символа).
char spis_kod[8192];       // Массив содержащий в режиме архивации список архивных кодов,
			   // в режиме разархивации буфер считаной из архивного файла информации побитно.

int i,j,l,s,s1,s2;
float f1,nom_v_der1;
long mngt;
long k;                    // Количество символов в прочитанном тексте.

char str_code[256];        // Строка в которую записывается код.
int bufer_code[256];       // Буфер кода.

int poz_spis_kod;          // Номер позиции в списке кодов spis_kod[]
			   // в которую будет выполнена следующая запись.

int bufer_poz;             // Номер позиции в буфере кода.

int kol_bit_bufer;         // Количество бит в буфере. (Используется в режиме разархивации).

int poz1, dlina1, code, tek_el_der, dop_byte;

int regim;                 // Режим вызова программы ('A'-Архивация,E'-Разархивация.)

long dl_ish_file;          // Длина исходного архивируемого файла.
char * uk_dl_ish_file;     // Указатель на длину исходного файла.

long adr_ssyl_tab;         // Адрес начала таблицы ссылочных элементов дерева Хаффмана.
char * uk_adr_ssyl_tab;    // Указатель на адрес начала таблицы ссылочных элементов дерева Хаффмана.

long adr_list_tab;         // Адрес начала таблицы листовых элементов дерева.
char * uk_adr_list_tab;    // Указатель на адрес начала таблицы листовых элементов дерева Хаффмана.

long adr_text;             // Адрес начала заархивированного текста.
char * uk_adr_text;        // Указатель на адрес начала заархивированного текста.

long kol_razarh_symb;       // Количество разархивированных символов.


//***************************************************************************
//*******  ПОДПРОГРАММА ОБХОДА ДЕРЕВА ХАФМАНА И ПОСТРОЕНИЯ КОДОВ  ***********
//
// Параметры :      N  -  Длина строки содержащей архивный код.
//              nomer  -  Номер элемента содержащего корень плддерева.


void obhod (int N, int nomer)

{

int i;

if (vid_elem[nomer]=='L')
  {
    // Текуший элемент дерева является листовым.

    // К строке содержащей код текущего символа добавить код признака
    // конца строки.
    str_code[N]='\0';

    // В массиве nom_poz_kod_symb[] запомнить номер позиции с которой
    // начинается код symb_elem[nomer].
    nom_poz_kod_symb[symb_elem[nomer]]=poz_spis_kod;

    // Записать в список кодов код очередного символа.
    i=0;
    while (str_code[i]!='\0')
      {
	spis_kod[poz_spis_kod]=str_code[i];
	i++;
	poz_spis_kod++;
      }

    // В массиве dl_kod_symb[] запомнить длину кода очередного символа.
    dl_kod_symb[symb_elem[nomer]]=i;

    if (poz_spis_kod>8192)
      {
	printf("\n  Ошибка !!!  Массив кодов символов переполнен.");
	while (1);
      }
  }

else
  {
    // Текущий элемент дерева является ссылкой.

    // В код добавить "0".
    str_code[N]='0';

    // Рекурсивный вызов функции OBHOD() для левой ветки.
    obhod(N+1,lev_ssylka[nomer]);

    // В код добавить "1".
    str_code[N]='1';

    // Рекурсивный вызов функции OBHOD() для правой ветки.
    obhod(N+1,prav_ssylka[nomer]);
  }

// Возврат из функции OBHOD().
return;

}

//***************************************************************************
//****************  ФУНКЦИЯ  ПОПОЛНЕНИЯ БУФЕРА ЧТЕНИЯ  **********************
//
// Функция читает заархивированный файл, раскладывает байты в биты записывает
// их в буфер. Если во время начала работы функции указатель чтения стоит
// на конце заархивированного файла, и ничего не удалось прочитать
// тогда функция возвращает 0, если же прочитать хотя бы что то удалось
// тогда функция возвращает 1.
//

int read_bufer()

{

char r0, r1, r2, r3, r4, r5, r6, r7;

int s, rez;


// Считать очередной символ из архивного файла.
s = fgetc(fp1);

// Установить начальное значение размера буфера чтения.
kol_bit_bufer=0;

// Пока архивный файл не кончился и буфер не заполнен.
while (!feof(fp1))
  {
    // Разложить считанный из архивного файла символ побитно.
    r0=s/128;
    s-=r0*128;

    r1=s/64;
    s-=r1*64;

    r2=s/32;
    s-=r2*32;

    r3=s/16;
    s-=r3*16;

    r4=s/8;
    s-=r4*8;

    r5=s/4;
    s-=r5*4;

    r6=s/2;
    s-=r6*2;

    r7=s;

    // Записать биты получившиеся в результате побитного разложения
    // считанного символа в буфер.
    spis_kod[kol_bit_bufer] = r0;
    kol_bit_bufer++;

    spis_kod[kol_bit_bufer] = r1;
    kol_bit_bufer++;

    spis_kod[kol_bit_bufer] = r2;
    kol_bit_bufer++;

    spis_kod[kol_bit_bufer] = r3;
    kol_bit_bufer++;

    spis_kod[kol_bit_bufer] = r4;
    kol_bit_bufer++;

    spis_kod[kol_bit_bufer] = r5;
    kol_bit_bufer++;

    spis_kod[kol_bit_bufer] = r6;
    kol_bit_bufer++;

    spis_kod[kol_bit_bufer] = r7;
    kol_bit_bufer++;

    // Выход из цикла заполнения буфера в том случае если
    // буфер заполнен.
    if (!(kol_bit_bufer<8192)) break;

    // Считать очередной символ из архивного файла.
    s = fgetc(fp1);
  }

// Установить начальное значение признака удачи заполнения буфера.
rez=1;

// Если буфер пуст и заархивированный файл закончился тогда
// сброс признака удачи заполнения буфера.
if ((kol_bit_bufer==0) && (feof(fp1))) rez=0;


// Выход из функции.
return rez;

}

//***************************************************************************
//******************       ГЛАВНАЯ ПРОГРАММА     ****************************

int main( int argc, char * argv[] )

{

// Установить значения указателей.

// Получить адрес ячейки памяти в которой храниться длина файла
// содержащего исходный текст.
uk_dl_ish_file= (char *) & dl_ish_file;

// Получить адрес ячейки памяти в которой храниться позиция в архивном
// файле с которой начинается таблица ссылочных элементов дерева Хаффмана.
uk_adr_ssyl_tab= (char *) & adr_ssyl_tab;

// Получиить адрес ячейки памяти в которой храниться позиция в архивном
// файле с которой начинается таблица листовых элементов дерева Хаффмана.
uk_adr_list_tab= (char *) & adr_list_tab;

// Получить адрес ячейки памяти в которой храниться позиция в архивном
// файле с которой начинается заархивированный текст.
uk_adr_text= (char *) & adr_text;

if (argc!=4)
  {  // Командная строка вызова программы записана не правильно,
     //	выдача сообщения об ошибке.
    printf(" \n  Ошибка в формате вызова программы !!!            ");
    printf(" \n  HAFMAN.EXE  Ключ  Файл источник   Файл результат ");
    return 1;
  }

// Установить начальное значение переменной "Режим работы".
regim=0;

if ( (* argv[1]=='a') || (* argv[1]=='A') || (* argv[1]=='а') || (* argv[1]=='А'))
  {
    // В командной строке вызова программы обнаружен ключ 'a' или 'A' ,
    // русская или английская. Установить режим архивации.
    regim=1;
  }


if (regim)
  {
    // Установлен режим архивации.

    // Открытие файла содержащего исходный текст для чтения в бинарном режиме.
    if ( (fp1=fopen(argv[2],"rb")) == NULL )
      {
	// Если открыть файл не удалось тогда выдать сообщение об ошибке.
	perror( argv[2] );
	return 1;
      }

    // Переместиться на конец файла содержащего исходный текст.
    fseek(fp1,0L,SEEK_END);

    // Определить длину файла содержащего исходный текст.
    dl_ish_file=ftell(fp1);

    // Заполнение массива кодов символов.
    for (i=0; i<256; i++) symb[i]=i;

    // Обнуление массива номеров позиций в массиве spis_kod[] с которого
    // начинается коды символов.
    for (i=0; i<256; i++) nom_poz_kod_symb[i]=0;

    // Обнуление массива длин кодов символов в массиве spis_kod[].
    for (i=0; i<256; i++) dl_kod_symb[i]=0;

    // Обнуление массива хранящего частоты символов.
    for (i=0; i<256; i++) f[i]=0.0;

    // Обнуление счетчика символов.
    k=0;

    // Считывание исходного текста из файла и составление таблицы частот символов.
    fseek(fp1,0L,SEEK_SET);
    s = fgetc(fp1);

    while (!feof(fp1))
      {
	// Увеличить на 1 счетчик повторений для текущего символа.
	f[s]++;
	// Увеличить на 1 счетчик прочитанных символов.
	k++;
	// Считывание следующего символа.
	s=fgetc(fp1);
      }

    // Закрыть файл из которого считывался исходный текст.
    fclose(fp1);

    if (k==0)
      {
	// Файл с текстом пуст. Выдача на экран предупреждающего сообшения.
	printf("\n  Файл с текстом пуст.");
	return 1;
      }

    // Определить частоты появления символов.
    for (i=0; i<256; i++) f[i]/=k;

    // Запомнить массив частот появлений символов.
    for (i=0; i<256; i++) fz[i]=f[i];

    // Сортировка массива символов по убыванию частоты.
    do
      {
	l=0;
	for (i=0; i<255; i++)
	  {
	    if (f[i+1]>f[i])
	      {
		f1=f[i];
		f[i]=f[i+1];
		f[i+1]=f1;

		s=symb[i];
		symb[i]=symb[i+1];
		symb[i+1]=s;

		l=1;
	      }
	  }
      }
    while (l==1);

    // Переписывание символов с ненулевой частотой из таблицы символов
    // в таблицу хранящую дерево Хаффмана в качестве листовых элементов
    // этого дерева.
    i=0;

    while ((i<256) && (f[i]>0.0))
      {
	// Заполнение поля левая ссылка. (Левая ссылка отсуствует).
	lev_ssylka[i]=32767;

	// Заполнение поля "Правая ссылка". (Правая ссылка отсуствует).
	prav_ssylka[i]=32767;

	// Заполнение поля "Вид элемента". (Вид элемента листовой).
	vid_elem[i]='L';

	// Заполнение поля "Символ элемента". (Поместить текущий символ).
	symb_elem[i]=symb[i];

	// Заполнение поля "Частота появления в тексте". (Поместить частоту текущего символа).
	f_elem[i]=f[i];

	// Заполнение поля "Номер соответствующего элемента в дереве".
	nom_v_der[i]=i;

	// Нарастить счетчик элементов
	i++;
      }


    // Запомнить количество листовых элементов дерева Хаффмана.
    k_list_el=i;

    // Задание текущего размера дерева Хаффмана.
    k_el_derevo=i;

    // Построение дерева Хаффмана.
    k_tab_f=i;

    while (k_tab_f>1)
      {
	// Создание нового элемента в дереве Хаффмана.

	// Заполнение поля "Левая ссылка" нового элемента дерева Хаффмана.
	lev_ssylka[k_el_derevo]=nom_v_der[k_tab_f-2];

	// Заполнение поля "Правая ссылка" нового элемента дерева Хаффмана.
	prav_ssylka[k_el_derevo]=nom_v_der[k_tab_f-1];

	// Заполнение поля "Вид элемента" нового элемента дерева Хаффмана.
	// (Вид элемента ссылочный).
	vid_elem[k_el_derevo]='S';

	// Заполнение поля "Символ элемента" нового элемента дерева Хаффмана.
	// (Символ элемента "Пробел".)
	symb_elem[k_el_derevo]=' ';

	// Заполнение поля "Частота" нового элемента дерева Хаффмана.
	// (Частота нового элеиента дерева равна сумме частот последнего
	//  и предпоследнего элемента таблицы частот).
	f_elem[k_el_derevo]=f[k_tab_f-1]+f[k_tab_f-2];

	// Создание нового элемента в таблице частот. Частота нового
	// элемента  равна сумме частот двух самых правых элементов
	// с самой малой частотой. Два самых правых элемента с самой
	// малой частотой удаляются.
	f[k_tab_f-2]=f_elem[k_el_derevo];

	// Поле "Cимвол" нового элемента таблицы частот заполнено пробелом.
	symb[k_tab_f-2]=' ';

	// Поле "Номер в дереве" нового элемента таблицы частот заполнить
	// номером соответствующего элемента в дереве.
	nom_v_der[k_tab_f-2]=k_el_derevo;

	// Увеличить на 1 размер дерева Хаффмана.
	k_el_derevo++;

	if (k_el_derevo>512)
	  {
	    printf("Ошибка !!! Размер дерева превысил 512.");
	    while (1);
	  }

	// Уменьшить на 1 длину таблицы частот.
	k_tab_f--;

	// Переместить новый элемент таблицы частот так чтобы таблица
	// частот была отсортированна по убыванию частоты.
	j=k_tab_f-1;

	while ((j>0)&&(f[j]>f[j-1]))
	  {
	    f1=f[j-1];
	    s=symb[j-1];
	    nom_v_der1=nom_v_der[j-1];

	    f[j-1]=f[j];
	    symb[j-1]=symb[j];
	    nom_v_der[j-1]=nom_v_der[j];

	    f[j]=f1;
	    symb[j]=s;
	    nom_v_der[j]=nom_v_der1;

	    j--;
	  }
      }

    // Обнуление номера позиции в списке кодов spis_kod[].
    poz_spis_kod=0;

    // Обход дерева Хаффмана и выдача в файл символов и соответствующих им кодов.
    // Вторым параметром передантся номер корневого элемента кодового дерева.
    obhod(0,k_el_derevo-1);

    // Открытие файла в который записывается кодировочная таблица.
    if ( (fp2=fopen("KOD_TABL.TXT","w")) == NULL )
      {
	// Если открыть файл не удалось тогда выдать сообщение об ошибке.
	perror("KOD_TABL.TXT");
	return 1;
      }

    // Выдать в файл кодировочной таблицы заголовок.
    fprintf(fp2,"\n       ТАБЛИЦА ЧАСТОТ И КОДОВ СИМВОЛОВ       ");
    fprintf(fp2,"\n    - - - - - - - - - - - - - - - - - - - -  ");

    // Выдать в файл кодировочной таблицы символы, частоты их появления
    // и коды символов.
    //
    // Перебор в цикле всех символов кодовой страницы.
    for (i=0; i<256; i++)
      {
	// Считать позицию в списке кодов с которой начинается код
	// очередного символа.
	poz1=nom_poz_kod_symb[i];

	// Считать длину кода очередного символа.
	dlina1=dl_kod_symb[i];

	// Считать код соответствующий очередному символу.
	j=0;
	while (j<dlina1)
	  {
	    str_code[j]=spis_kod[poz1+j];
	    j++;
	  }
	str_code[j]='\0';

	// Выдать в файл кодировочной таблицы очередной символ, частоту его
	// появления и код этого символа.
	fprintf(fp2,"\n  %c  %d   %13.11f  %s ",i,i,fz[i],str_code);
	printf("\n  %c  %d   %13.11f  %s ",i,i,fz[i],str_code);
      }

    // Закрыть файл в который записывается кодировочная таблица.
    fclose(fp2);

    // Открыть файл для записи в бинарном режиме в который записывается
    // результат архивации.
    if ( (fp3=fopen(argv[3],"wb")) == NULL )
      {
	// Если открыть файл не удалось тогда выдать сообщение об ошибке.
	perror( argv[3] );
	return 1;
      }

    // Открытие файла содержащего исходный текст для чтения в бинарном режиме.
    if ( (fp1=fopen(argv[2],"rb")) == NULL )
      {
	// Если открыть файл не удалось тогда выдать сообщение об ошибке.
	perror( argv[2] );
	return 1;
      }

    // Записать в архивный файл "XY" - признак архивного файла XY- формата.
    fputc('X',fp3);
    fputc('Y',fp3);

    // Записать в архивный файл размер исходного архивируемого файла.
    fprintf(fp3,"%c%c%c%c", *(uk_dl_ish_file+0), *(uk_dl_ish_file+1), *(uk_dl_ish_file+2), *(uk_dl_ish_file+3) );

    // Зарезервировать 8 байт под таблицу разделов архивного файла.
    for (i=0; i<8; i++) fputc(0,fp3);

    // Записать дерево Хаффмана в архивный файл.

    // Записать ссылочные элементы дерева Хаффмана в архивный файл.
    for (i=0;i<k_el_derevo;i++)
       {
	  if (vid_elem[i]=='S')
	    {
	      // Очередной элемент дерева Хаффмана является ссылочным.
	      //
	      // Задать начальное значение дополнительного байта.
	      dop_byte=0;

	      // Записать левую ссылку этого элемента в таблицу
	      // ссылочных элементов дерева Хаффмана архивного файла.
	      if (vid_elem[lev_ssylka[i]]=='L')
		{
		  fputc(lev_ssylka[i],fp3);
		  dop_byte+=240;
		}
	      else
		{
		  fputc(lev_ssylka[i]-k_list_el,fp3);
		}

	      // Записать правую ссылку этого элемента в таблицу
	      // ссылочных элементов дерева Хаффмана архивного файла.
	      if (vid_elem[prav_ssylka[i]]=='L')
		{
		  fputc(prav_ssylka[i],fp3);
		  dop_byte+=15;
		}
	      else
		{
		  fputc(prav_ssylka[i]-k_list_el,fp3);
		}

	      // Записать дополнительный байт в таблицу ссылочных
	      // элементов дерева Хаффмана архивного файла.
	      fputc(dop_byte,fp3);
	    }
       }

    // Запомнить позицию в архивном файле с которой начинается
    // таблица листовых элементов дерева Хаффмана.
    adr_list_tab = ftell(fp3);

    // Записать листовые элементы дерева Хаффмана в архивный файл.
    for (i=0;i<k_el_derevo;i++)
       {
	  if (vid_elem[i]=='L')
	    {
	      // Очередной элемент дерева Хаффмана является листовым.
	      // Записать код символа соответствующего данному листовому
	      // элементу в таблицу листовых элементов дерева Хаффмана
	      // архивного файла.
	      fputc(symb_elem[i],fp3);
	    }
       }

    // Запомнить позицию в архивном файле с которой начинается
    // заархивированный текст.
    adr_text=ftell(fp3);

    // Записать в создаваемый архивный файл адрес начала таблицы листовых
    // элементов дерева Хаффмана.
    fseek(fp3,6L,SEEK_SET);
    fprintf(fp3,"%c%c%c%c", *(uk_adr_list_tab+0), *(uk_adr_list_tab+1), *(uk_adr_list_tab+2), *(uk_adr_list_tab+3) );

    // Записать в создаваемый архивный файл адрес начала заархивированного
    // текста.
    fseek(fp3,10L,SEEK_SET);
    fprintf(fp3,"%c%c%c%c", *(uk_adr_text+0), *(uk_adr_text+1), *(uk_adr_text+2), *(uk_adr_text+3) );

    // Переместить указатель заархивированного файла на конец.
    fseek(fp3,adr_text,SEEK_SET);

    // Задание начального значения номера позиции в буфере кода.
    bufer_poz=0;

    // Переместиться в начало файла содержащего исходный текст.
    fseek(fp1,0L,SEEK_SET);

    // Считать первый символ.
    s = fgetc(fp1);

    // Считывание исходного текста из файла и его кодирование.
    while (!feof(fp1))
      {
	// Считать позицию в списке кодов с которой начинается код
	// очередного символа.
	poz1=nom_poz_kod_symb[s];

	// Считать длину кода очередного символа.
	dlina1=dl_kod_symb[s];

	// Считать код соответствующий очередному символу в буфер.
	j=0;
	while (j<dlina1)
	  {
	    // Записать в буфер очередной разряд кода.
	    bufer_code[bufer_poz]= (int) spis_kod[poz1+j]-48;
	    // Увеличить на 1 номер текущей позиции в буфере и счетчик разрядов кода.
	    bufer_poz++;
	    j++;
	  }

	// Считывать порции по 8 разрядов из буфера, преобразовать их в
	// байты и записывать в файл содержащий результаты кодирования.
	while (bufer_poz>7)
	  {
	    // Считать левые восемь разрядов буфера и превратить их
	    // в код символа.
	    code=bufer_code[0]*128+bufer_code[1]*64+bufer_code[2]*32;
	    code+=bufer_code[3]*16+bufer_code[4]*8+bufer_code[5]*4;
	    code+=bufer_code[6]*2+bufer_code[7]*1;

	    // Записать полученный код символа в файл содержащий
	    // результат кодирования.
	    fputc(code,fp3);

	    // Сдвижка в буфере.
	    for (j=8; j<bufer_poz; j++) bufer_code[j-8]=bufer_code[j];

	    // Уменьшить длину буфера на 8.
	    bufer_poz-=8;
	  }

	// Считывание следующего символа.
	s=fgetc(fp1);
      }

    if (bufer_poz>0)
      {
	// Буфер не пуст.
	if (bufer_poz<8)
	  {
	    // В буфере остаток кода менее 8 разрядов.
	    //
	    // Дополнить содержимое буфера до 8 разрядов.
	    while (bufer_poz<8)
	      {
		bufer_code[bufer_poz]=0;
		bufer_poz++;
	      }

	    // Считать левые восемь разрядов буфера и превратить их
	    // в код символа.
	    code=bufer_code[0]*128+bufer_code[1]*64+bufer_code[2]*32;
	    code+=bufer_code[3]*16+bufer_code[4]*8+bufer_code[5]*4;
	    code+=bufer_code[6]*2+bufer_code[7]*1;

	    // Записать полученный код символа в файл содержащий
	    // результат кодирования.
	    fputc(code,fp3);
	  }
	else
	  {
	    // В буфере остаток кода 8 или более разрядов. Ошибочная ситуация.
	    printf("Ошибка !!!. После завершения кодирования в буфере остаток кода 8 или более разрядов. ");
	    while (1);
	  }
      }

    // Закрыть файл из которого считывался исходный текст.
    fclose(fp1);

    // Закрыть файл в который записывается результат кодирования.
    fclose(fp3);
  }

else
  {
    // Установлен режим разархивации.

    // Открытие файла содержащего архив для чтения в бинарном режиме.
    if ( (fp1=fopen(argv[2],"rb")) == NULL )
      {
	// Если открыть файл не удалось тогда выдать сообщение об ошибке.
	perror( argv[2] );
	return 1;
      }

    // Переместиться на начало архивного файла.
    fseek(fp1,0L,SEEK_SET);

    // Прочитать первые два символа архивного файла.
    s1 = fgetc(fp1);
    s2 = fgetc(fp1);

    if ((s1!='X') || (s2!='Y'))
      {
	// Первые два символа не 'XY'.
	// Данный файл не является архивным файлом.
	printf("\n  Данный файл не является архивом.");
	printf("\n  Разархивация не возможна.       ");
	return 1;
      }

    // Открытие файла в который записывается результат разархивации.
    if ( (fp2=fopen(argv[3],"wb")) == NULL )
      {
	// Если открыть файл не удалось тогда выдать сообщение об ошибке.
	perror( argv[3] );
	return 1;
      }

    // Считать из архивного файла размер исходного файла в байтах.
    for (i=0,mngt=1,dl_ish_file=0; i<4; i++,mngt*=256) dl_ish_file+=mngt*(long) getc(fp1);

    // Адрес начала таблицы ссылочных элементов дерева Хаффмана = 14.
    adr_ssyl_tab=14;

    // Считать из архивного файла позицию в архивном файле с которой
    // начинается таблица листовых элементов дерева Хаффмана.
    for (i=0,mngt=1,adr_list_tab=0; i<4; i++,mngt*=256) adr_list_tab+=mngt*(long) getc(fp1);

    // Считать из архивного файла позицию в архивном файле с которой
    // начинается заархивированный текст.
    for (i=0,mngt=1,adr_text=0; i<4; i++,mngt*=256) adr_text+=mngt*(long) getc(fp1);

    // Определить количество листовых элементов дерева Хаффмана.
    k_list_el = (int) adr_text-adr_list_tab;

    // Считать из архивного файла листовые элементы дерева Хаффмана.
    fseek(fp1,adr_list_tab,SEEK_SET);
    for (i=0; i<k_list_el; i++)
      {
	// Установить что элемент является листовым.
	vid_elem[i]='L';
	// Обнулить левую ссылку.
	lev_ssylka[i]=0;
	// Обнулить правую ссылку.
	prav_ssylka[i]=0;
	// Считать символ данного листового элемента.
	symb_elem[i]=getc(fp1);
      }

    // Определить количество ссылочных элементов дерева Хаффмана.
    k_ssyl_el= (int) (adr_list_tab-adr_ssyl_tab)/3;

    // Считать из архивного файла ссылочные элементы дерева Хаффмана.
    fseek(fp1,adr_ssyl_tab,SEEK_SET);

    for (i=0; i<k_ssyl_el; i++)
      {
	// Считать из архивного файла два байта и третий дополнительный байт
	// в которых записан очередной элемент дерева Хаффмана.
	s1 = fgetc(fp1);
	s2 = fgetc(fp1);
	dop_byte = fgetc(fp1);

	// Сформировать номер элемента массива в который будет сделана запись
	// очередного ссылдочного элемента.
	j=k_list_el+i;

	if ((dop_byte&240)==0)
	  {
	    lev_ssylka[j]=s1+k_list_el;
	  }
	else
	  {
	    lev_ssylka[j]=s1;
	  }

	if ((dop_byte&15)==0)
	  {
	    prav_ssylka[j]=s2+k_list_el;
	  }
	else
	  {
	    prav_ssylka[j]=s2;
	  }

	// Установить что элемент является ссылочным.
	vid_elem[j]='S';
      }

    // Определить общее количество элементов в дереве Хаффмана.
    k_el_derevo=k_list_el+k_ssyl_el;

    // Получить номер корневого элемента кодового дерева.
    nom_koren=k_el_derevo-1;

    // Текущим элементом дерева сделать корневой элемент дерева.
    tek_el_der=nom_koren;

    // Обнулить счетчик разархивированных символов.
    kol_razarh_symb=0;

    // Переместить указатель на начало заархивированного текста.
    fseek(fp1,adr_text,SEEK_SET);

    // Пока удается считывать заархивированный файл.
    while (read_bufer())
      {
	// Переместить указатель позиции в буфере на начало буфера.
	bufer_poz=0;

	// Пока буфер не исчерпан.
	while (bufer_poz<kol_bit_bufer)
	  {
	    if (!(vid_elem[tek_el_der]=='L'))
	      {
		// Текущий элемент кодового дерева является ссылочным.
		//
		// Считать очередной бит из буфера.
		code=spis_kod[bufer_poz];

		if (code==1)
		  {
		    // Очередной считанный из буфера бит равен 1.
		    // Перейти на правую ссылку текущего элемента.
		    tek_el_der=prav_ssylka[tek_el_der];
		  }
		else
		  {
		    // Очередной считанный из буфера бит равен 0.
		    // Перейти на левую ссылку текущего элемента.
		    tek_el_der=lev_ssylka[tek_el_der];
		  }

		// Перейти к следующему биту из буфера.
		bufer_poz++;
	      }

	    if (vid_elem[tek_el_der]=='L')
	      {
		// Текущий элемент кодового дерева является листовым.
		//
		// Считать символ из текущего листового элемента кодового
		// дерева.
		code=symb_elem[tek_el_der];

		if (kol_razarh_symb<dl_ish_file)
		  {
		    // Количество разархивированных символов меньше
		    // чем количество символов в исходном файле.
		    //
		    // Выдать считанный символ в файл содержащий результат
		    // разархивации.
		    fputc(code,fp2);
		  }

		// Увеличить на 1 счетчик разархивированных и записанных
		// в выходной файл символов.
		kol_razarh_symb++;

		// Текущим элементом дерева сделать корневой элемент дерева.
		tek_el_der=nom_koren;
	      }

	  }
      }

    // Закрыть файл в который записывается результат разархивации.
    fclose(fp2);

    // Закрыть файл из которого считывался архив.
    fclose(fp1);
  }


return 0;

}